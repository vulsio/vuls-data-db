name: Summary Action Run

on:
  workflow_call: {}
  workflow_dispatch:
    inputs:
      run_id:
        description: "Run ID to check (blank = current run)"
        required: false
        type: string

permissions:
  contents: read
  actions: read

jobs:
  report:
    name: Action run summary
    runs-on: ubuntu-latest
    steps:
      - name: Collect action run summary
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          INPUT_RUN_ID: ${{ inputs.run_id }}
        run: |
          set -euo pipefail

          RUN_ID="${INPUT_RUN_ID:-$GITHUB_RUN_ID}"

          # --- fetch run metadata -----------------------------------------------
          run_json=$(gh run view "$RUN_ID" --json 'createdAt,url,jobs,name,status')

          wf_name=$(echo "$run_json" | jq -r '.name // "Unknown"')
          url=$(echo "$run_json" | jq -r '.url')
          created=$(echo "$run_json" | jq -r '.createdAt')

          {
            echo "# ðŸ” ${wf_name} â€” Failure Report"
            echo ""
            echo "_Run [#${RUN_ID}](${url}) | started ${created} | checked $(date -u +'%Y-%m-%d %H:%M:%S') UTC_"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          # --- collect failed jobs ------------------------------------------------
          failed_jobs=$(echo "$run_json" \
            | jq -r '.jobs[] | select(.conclusion == "failure") | "\(.name)"')

          n_failed=$(echo "$failed_jobs" | grep -c . || true)

          if [[ "$n_failed" -eq 0 ]]; then
            echo "âœ… All jobs succeeded." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "### âŒ Failed jobs (${n_failed})" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # --- get failed logs ----------------------------------------------------
          log_file=$(mktemp)
          log_err=$(mktemp)
          run_status=$(echo "$run_json" | jq -r '.status // "unknown"')

          # Only attempt gh run view --log-failed when the run is completed;
          # for in-progress runs (workflow_call within the same run) the
          # command always fails, so skip it to avoid a noisy warning.
          if [[ "$run_status" == "completed" ]]; then
            gh run view "$RUN_ID" --log-failed > "$log_file" 2> "$log_err" || true
          fi

          # If --log-failed was skipped or returned empty, try alternatives
          if [[ ! -s "$log_file" ]]; then
            if [[ "$run_status" != "completed" ]]; then
              : # expected for workflow_call within the same run
            elif [[ -s "$log_err" ]]; then
              echo "::warning::gh run view --log-failed produced no output: $(cat "$log_err")"
            else
              echo "::warning::gh run view --log-failed produced no output (no stderr either)"
            fi

            # Fallback 1: fetch per-job logs via REST API.
            # Even when the workflow run is still in progress, completed
            # (failed) jobs already have their logs available.
            : > "$log_file"
            while IFS= read -r job_name; do
              job_id=$(echo "$run_json" | jq -r --arg name "$job_name" \
                '.jobs[] | select(.name == $name) | .databaseId')
              [[ -n "$job_id" && "$job_id" != "null" ]] || continue

              job_log=$(mktemp)
              if gh api "repos/${GH_REPO}/actions/jobs/${job_id}/logs" > "$job_log" 2>> "$log_err"; then
                # Parse per-job log: extract step names from ##[group] markers
                # and construct TSV format: job_name\tstep_name\tline
                awk -v job="$job_name" '
                  /##\[group\]/ {
                    sub(/.*##\[group\]/, "")
                    current_step = $0
                    next
                  }
                  /##\[endgroup\]/ { next }
                  { printf "%s\t%s\t%s\n", job, current_step, $0 }
                ' "$job_log" >> "$log_file"
              else
                echo "::warning::Failed to fetch logs for job ${job_name} (${job_id})"
              fi
              rm -f "$job_log"
            done <<< "$failed_jobs"

            if [[ -s "$log_file" ]]; then
              : # per-job logs fetched successfully
            else
              # Fallback 2: download run-level log archive
              log_zip=$(mktemp -u).zip
              if gh api "repos/${GH_REPO}/actions/runs/${RUN_ID}/logs" > "$log_zip" 2>> "$log_err"; then
                log_dir=$(mktemp -d)
                unzip -q -o "$log_zip" -d "$log_dir" 2>/dev/null || true
                for job_dir in "$log_dir"/*/; do
                  [[ -d "$job_dir" ]] || continue
                  job_base=$(basename "$job_dir")
                  for step_file in "$job_dir"*.txt; do
                    [[ -f "$step_file" ]] || continue
                    step_base=$(basename "$step_file" .txt)
                    while IFS= read -r line; do
                      printf '%s\t%s\t%s\n' "$job_base" "$step_base" "$line"
                    done < "$step_file"
                  done
                done >> "$log_file"
                rm -rf "$log_dir" "$log_zip"
                echo "::notice::Fetched logs via run-level archive fallback ($(wc -l < "$log_file") lines)"
              else
                echo "::warning::REST API log download also failed: $(cat "$log_err")"
              fi
            fi
          fi
          rm -f "$log_err"

          while IFS= read -r job_name; do
            echo "---" >> "$GITHUB_STEP_SUMMARY"
            echo "#### ${job_name}" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"

            if [[ ! -s "$log_file" ]]; then
              echo "(no log available)" >> "$GITHUB_STEP_SUMMARY"
              continue
            fi

            ################################################################
            # 1) Error snippet: matching lines with Â±3 lines of context
            ################################################################
            msg_file=$(mktemp)
            awk -F'\t' -v job="$job_name" '$1 == job { print $3 }' "$log_file" \
              | { grep -vE '[0-9]+% *\|[â–ˆâ–“â–’â–‘ ]*\||^\s*$|^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9:.]+Z\s*$' || true; } > "$msg_file"

            # --- echo captured log to Actions console output ---
            echo "::group::Captured log for ${job_name}"
            cat "$msg_file"
            echo "::endgroup::"

            error_lines_file=$(mktemp)
            grep -n -iE \
              "error[^s_-]|error$|panic|fatal|exception|timed? ?out|: fail|exit (code|status)" \
              "$msg_file" > "$error_lines_file" || true

            first_frame=$(grep -n -E '(^|Z )(github\.com|[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+/)' "$msg_file" \
              | head -1 | cut -d: -f1 || true)
            if [[ -n "$first_frame" && "$first_frame" -gt 1 ]]; then
              err_line=$((first_frame - 1))
              if ! grep -q "^${err_line}:" "$error_lines_file" 2>/dev/null; then
                echo "${err_line}:$(sed -n "${err_line}p" "$msg_file")" >> "$error_lines_file"
              fi
            fi

            error_snippet=""
            if [[ -s "$error_lines_file" ]]; then
              sed_expr=$(head -20 "$error_lines_file" \
                | cut -d: -f1 \
                | awk '
                  { lines[NR] = $1 }
                  END {
                    for (i = 1; i <= NR; i++) {
                      lo = lines[i] - 3; if (lo < 1) lo = 1
                      hi = lines[i] + 3
                      printf "%d,%dp\n", lo, hi
                    }
                  }
                ' \
                | sort -t, -k1,1n -u \
                | paste -sd';')

              if [[ -n "$sed_expr" ]]; then
                error_snippet=$(sed -n "$sed_expr" "$msg_file" | head -c 4000 || true)
              fi
            fi
            rm -f "$error_lines_file"

            if [[ -n "$error_snippet" ]]; then
              {
                echo '```'
                echo "$error_snippet"
                echo '```'
              } >> "$GITHUB_STEP_SUMMARY"
            else
              echo "(no recognisable error lines captured)" >> "$GITHUB_STEP_SUMMARY"
            fi

            ################################################################
            # 2) Detailed log: Go stack trace with preceding context,
            #    or last 200 lines if no trace is found.
            ################################################################
            echo "" >> "$GITHUB_STEP_SUMMARY"

            failed_step=$(echo "$run_json" \
              | jq -r --arg job "$job_name" '
                .jobs[]
                | select(.name == $job)
                | .steps[]
                | select(.conclusion == "failure")
                | .name
              ' | head -1)
            : "${failed_step:=unknown}"

            msg_line_count=$(wc -l < "$msg_file")

            trace_start=$(grep -n -E "(^|Z )(goroutine [0-9]+|panic[:(]|runtime[./])" "$msg_file" \
              | head -1 | cut -d: -f1 || true)

            step_extract=$(mktemp)
            if [[ -n "$trace_start" && "$trace_start" -gt 1 ]]; then
              info_start=$((trace_start > 5 ? trace_start - 5 : 1))
              sed -n "${info_start},$((trace_start - 1))p" "$msg_file" >> "$step_extract"
              echo "--- (stack trace starts here) ---" >> "$step_extract"
              tail -n +"$trace_start" "$msg_file" | head -200 >> "$step_extract"
            else
              tail -200 "$msg_file" >> "$step_extract"
            fi

            if [[ -s "$step_extract" ]]; then
              {
                echo "<details><summary>Log: ${failed_step} (${msg_line_count} lines total)</summary>"
                echo ""
                echo '```'
                head -c 65000 "$step_extract"
                echo '```'
                echo ""
                echo "</details>"
              } >> "$GITHUB_STEP_SUMMARY"
            fi

            rm -f "$step_extract"

            rm -f "$msg_file"
          done <<< "$failed_jobs"

          rm -f "$log_file"
